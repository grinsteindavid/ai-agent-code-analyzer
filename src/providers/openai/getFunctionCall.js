const { OpenAI } = require("openai");
const { tools } = require("../../utils/tools");
const { getMessages, addMessage, getCurrentDirectory} = require("../../utils/context");

// Initialize OpenAI
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

/**
 * Call OpenAI API and get function call response
 * @param {Object} options - Options object
 * @param {Array} [options.functions=[]] - Array of function definitions
 * @param {String} [options.nextThought] - The next thought generated by getNextThought
 * @returns {Object|null} - Function call with name and arguments, or null if error
 */
async function getFunctionCall(options) {
  // Default options
  const {
    functions = [],
    nextThought = "",
  } = options;

  if(nextThought === "STOP EXECUTION") {
    return null;
  }
  
  const response = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [
      // System message with instructions
      { role: 'system', content: `
        You are a helpful assistant. \n
  
        Always include the Current directory for paths: ${getCurrentDirectory()} \n
  
        You can ONLY use Availabl tools:
        ${Object.entries(tools).map(([name, {schema}]) => `** ${name}: ${schema.description}`).join('\n')}
  
        IMPORTANT:
        1. If "Next thought" is equal to "STOP EXECUTION" then STOP and NEVER return a function call
        2. Check if all previous function calls with their errors and results fullfill the plan goal
        3. If previous function calls have failed, try a different approach
        4. If the plan goal has been fully achieved or next thought is "EXECUTION PLAN GOAL ACHIEVED", do NOT return any more function calls
        5. If the plan goal has not been achieved, return a function call
        6. If no steps of the plan goal have been executed yet, return a function call
        7. Return ONLY the function call with name and arguments, do not include any additional text
        8. Craft your arguments wisely based on the next thought
       ` 
      },
      // Include conversation history
      ...getMessages().map(msg => ({ role: msg.role, content: msg.content })),
      { role: 'assistant', content: `Next thought: ${nextThought}` },
    ],
    tools: functions,
    parallel_tool_calls: false,
  });
  

  const message = response.choices[0]?.message;
  
  // Check for tool_calls first (new OpenAI API format)
  if (message?.tool_calls && message.tool_calls.length > 0) {
    const toolCall = message.tool_calls[0];
    if (toolCall.type === 'function') {
      const functionCall = toolCall.function;

      return {
        name: functionCall.name,
        arguments: JSON.parse(functionCall.arguments)
      };
    }
  }
  // Check for direct function_call property (legacy format)
  else if (message?.function_call) {
    const functionCall = message.function_call;

    return {
      name: functionCall.name,
      arguments: JSON.parse(functionCall.arguments)
    };
  } 
  // Check if the content field contains function call information as a JSON string
  else if (message?.content && typeof message.content === 'string') {
    try {
      // Try to parse the function content as JSON
      let contentJson
      try {
        contentJson = JSON.parse(message.content);
      } catch (error) {
        return null;
      }
      
      const toolName = contentJson.name;
      const args = typeof contentJson.arguments === 'string' 
      ? JSON.parse(contentJson.arguments) 
      : contentJson.arguments;

      // Check if the parsed content has the expected function call structure
      if (toolName && args) {
        
        return {
          name: toolName,
          arguments: args
        };
      }
    } catch (error) {
      addMessage(getNextMessageRole(), `ERROR: ${error.message}`);
      throw error;
    }
    
  }
  
  return null;
}

module.exports = getFunctionCall;
