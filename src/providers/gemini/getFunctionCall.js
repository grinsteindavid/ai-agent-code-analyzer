const { GoogleGenerativeAI } = require("@google/generative-ai");
const os = require('os');
const { tools } = require("../../utils/tools");
const { getMessages, addMessage } = require("../../utils/context");

// Initialize Gemini API
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

/**
 * Call Gemini API and get function call response
 * @param {Object} options - Options object
 * @param {Array} [options.functions=[]] - Array of function definitions
 * @param {String} [options.nextThought] - The Next action generated by getNextThought
 * @returns {Object|null} - Function call with name and arguments, or null if error
 */
async function getFunctionCall(options) {
  // Default options
  const {
    functions = [],
    nextThought = "",
  } = options;

  if(nextThought.toLowerCase().includes("@stop execution@")) {
    return null;
  }
  
  try {
    // Convert OpenAI tool format to Gemini function format if needed
    const geminiFunctions = functions.map(tool => ({
      name: tool.function.name,
      description: tool.function.description,
      parameters: tool.function.parameters
    }));

    // Prepare system instruction
    const systemInstruction = `
        You are a helpful assistant. \n
        
        ** Operating system info: ${process.platform} (${process.arch}) ${os.release()} ** 
        ** Operating system user home directory (global configurations): ${os.userInfo().homedir} ** 
        ** Operating system username: ${os.userInfo().username} ** 
        ** Operating system shell: ${os.userInfo().shell} ** 
        ** Node.js version: ${process.version} ** 
        ** Current working directory: ${process.cwd()} ** 
        
        -----------------
        You can ONLY use Available tools:
        ${Object.entries(tools).map(([name, {schema}]) => `** ${name}: ${schema.description}`).join('** \n')}
        -----------------
  
        IMPORTANT:
        1. If "Next action" is equal to "@STOP EXECUTION@" or "@stop execution@" or say something about doing it then STOP and NEVER return a function call.
        2. Return ONLY the function call with name and arguments, do not include any additional text.
        3. Craft your arguments wisely based on the provided "Next action" AND ENTIRE CONVERSATION.
        4. when creating or updating files, always check file content before updating to avoid errors and keep correct format also structure.
      `;

    // Create the model with system instruction
    const model = genAI.getGenerativeModel({ 
      model: "gemini-1.5-flash",
      systemInstruction: systemInstruction,
      tools: geminiFunctions
    });

    // Format conversation history for Gemini
    const chatHistory = getMessages().map(msg => ({
      role: msg.role === 'assistant' ? 'model' : msg.role,
      parts: [{ text: msg.content }]
    }));
    
    // Prepare the content for generation
    const contents = [
      ...chatHistory,
      { role: 'user', parts: [{ text: `Next action: ${nextThought}` }] }
    ];
    
    // Generate content with the new API pattern
    const result = await model.generateContent({
      contents,
      generationConfig: {
        temperature: 0.1,
        maxOutputTokens: 1024,
      }
    });
    
    // Get the full response text
    const fullResponse = result.response.text();

    // Try to parse the response as JSON with function call format
    try {
      // Try to parse the response as a function call in JSON format
      const responseJson = JSON.parse(fullResponse);
      
      if (responseJson.name && responseJson.arguments) {
        return {
          name: responseJson.name,
          arguments: typeof responseJson.arguments === 'string' 
            ? JSON.parse(responseJson.arguments) 
            : responseJson.arguments
        };
      }
    } catch (parseError) {
      // If the response isn't valid JSON, try to extract function call using regex
      const functionMatch = fullResponse.match(/\{\s*"name"\s*:\s*"([^"]+)"\s*,\s*"arguments"\s*:\s*(\{[^}]+\})\s*\}/);
      
      if (functionMatch && functionMatch.length >= 3) {
        const name = functionMatch[1];
        const argsStr = functionMatch[2];
        
        try {
          const args = JSON.parse(argsStr);
          return {
            name: name,
            arguments: args
          };
        } catch (innerError) {
          addMessage(`user`, `ERROR parsing function arguments: ${innerError.message}`);
        }
      }
    }
    
    return null;
  } catch (error) {
    addMessage(`user`, `ERROR: ${error.message}`);
    return null;
  }
}

module.exports = getFunctionCall;
